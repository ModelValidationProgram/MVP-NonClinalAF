---
title: "1-AnalyzeSims"
author: "KE Lotterhos"
date: "3/12/2021"
output: html_document
---

setwd("~/Documents/GitHub/MVP-NonClinalAF/src")

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

packages_needed <- c("vcfR", "distances","ggplot2",  "fields", "stringr", "vegan", "robust", "mvtnorm")

for (i in 1:length(packages_needed)){
  if(!(packages_needed[i] %in% installed.packages())){install.packages(packages_needed[i])}
}

#  require(ggplot2)}

for (i in 1:length(packages_needed)){
  library( packages_needed[i], character.only = TRUE)
}
```

## 
```{r load data, include=FALSE}
path <- "../sim_outputs/"
outpath <- "../results/"

seed <- 2242330863068

#2242330863068_popInfo

# Individual phenotype and fitness data in home pop
indPhen_df <- read.table(paste0(path,seed,"_ind.txt"), header=TRUE, 
                         colClasses = c("character", rep("numeric",8)))
head(indPhen_df)

pop_df <- read.table(paste0(path,seed,"_popInfo.txt"), header=TRUE, 
                         colClasses = c("character", rep("numeric",6))) 

# Local adaptation through time df
LA_df <- read.table(paste0(path,seed,"_LA.txt"), header=TRUE, 
                         colClasses = c("character", rep("numeric",10)),
                    na.strings = "NAN")
str(LA_df)
head(LA_df)
tail(LA_df)

# Mutation stats for MAF > 0.01
muts_df <- read.table(paste0(path,seed,"_muts.txt"), header=TRUE, 
                         colClasses = c("character", rep("numeric",6)))
head(muts_df)

info <- read.table(paste0(path,seed,"_info.txt"), header=TRUE, 
                         colClasses = c("character", "character",
                                        rep("numeric",13)))
info

# VCF file
vcf <- read.vcfR(paste0(path,seed,"_VCF_causal.vcf.gz"))
head(vcf)
head(vcf@fix, 50)
dim(vcf@fix)
# example of how to find a specific mutation in the vcf file
  muts_df[1,]
  vcf@fix[grep(muts_df$mutID[1], vcf@fix[,"INFO"]),]
  

# VCF with mutations
vcf_full <- read.vcfR(paste0(path,seed,"_plusneut_MAF01.recode2.vcf.gz"))
head(vcf_full)
head(vcf_full@fix, 50)
dim(vcf_full@fix)

#vcf_full@fix[15:16,]
#vcf_full@gt[15:16,1:10]
```


```{r plot subpops and migration}
mig <- read.table(paste0(path,seed,"_popInfo_m.txt"), header=TRUE)
head(pop_df)
head(mig)

plot(pop_df$x, pop_df$y, col=rgb(0,0,0,0))
mig_thick <- scale(mig$m) + abs(min(scale(mig$m)))+1
for (i in 1:nrow(mig)){
  start_x <- pop_df$x[which(pop_df$subpopID==mig$from[i])]
  start_y <- pop_df$y[which(pop_df$subpopID==mig$from[i])]
  end_x <- pop_df$x[which(pop_df$subpopID==mig$to[i])]
  end_y <- pop_df$y[which(pop_df$subpopID==mig$to[i])]
  adj = 0.01
  arrows(start_x,start_y,end_x, end_y, col=rgb(0,0,1,0.5), lwd=mig_thick[i], length = 0.1)
}
text(pop_df$x, pop_df$y+0.25, pop_df$subpopID, cex=1)

plot(pop_df$x, pop_df$y, col=rgb(0,0,0,0))
text(pop_df$x, pop_df$y, pop_df$N)

plot(pop_df$x, pop_df$y, col=rgb(0,0,0,0), main="opt0")
text(pop_df$x, pop_df$y, round(pop_df$opt0, 1))

plot(pop_df$x, pop_df$y, col=rgb(0,0,0,0), main="opt1")
text(pop_df$x, pop_df$y, round(pop_df$opt1, 1))

plot(pop_df$x, pop_df$y)

```

```{r, echo=FALSE, eval=FALSE}
# Sanity check
# the fitness column in the indPhen_df gives
  # the fitnesses in the home population (subpop)
# these should match the fitnesses in the same
  # subpop in the common garden data frame
# Individual common garden data
indCG_df<- read.table(paste0(path,seed,"_fitnessmat_ind.txt"))
dim(indCG_df)
rownames(indCG_df) = c("popID", 1:(nrow(indCG_df)-1))
head(indCG_df[,1:20])
  # the first row in this is popID
    head(indPhen_df)
 head(indCG_df[,1:10])
 cbind(round(indPhen_df$fitness[1:10],6), 
            unlist(round(indCG_df[2,1:10],6)))
  
  # hard coding
  cbind(round(indPhen_df$fitness[1990:2000],6), 
            unlist(round(indCG_df[21,1990:2000],6)))
  
  cor(indPhen_df$fitness,indPhen_df$sal_opt)
  cor(indPhen_df$phen_sal,indPhen_df$sal_opt)

```

First, I want to figure out which individuals are migrants. Sampling in the simulation occurred after migration but before selection, so for analysis I want to make sure to only include individuals that would have survived to reproduce.

My goal is to start with a dataset of 50 pops * 20 individuals = 1000 individuals, with approximately equal number of individuals per population.


(Part 1) I tried to subset the data to individuals who have highest fitness in their home population, but this does not give equal numbers.

(Part 2) Decision: sample X individuals from each population with probability equal to their fitness. This will make the sampling less artificial.

Note that this sampling doesn't really make a huge difference in terms of the correlation between salinity and temperature.
```{r find high fitness individuals}

### Part 1 ####
  # sum(indPhen_df[,"fitness"]>0.8)
  # sum(indPhen_df[,"fitness"]>0.9)
  # sum(indPhen_df[,"fitness"]>0.95)
  # 
  # subset <- which(indPhen_df[,"fitness"]>0.95)
  # length(subset)
  # table(indPhen_df[subset,"subpop"])
  
### Part 2 ####
  npops <- length(levels(factor(indPhen_df$subpop)))
  n = 20 # number of individual per pop
  subset <- c()
  for (i in 1:npops){
    #set.seed(139982)
    bob <- sample(indPhen_df$indID[indPhen_df$subpop==i], size = n,
                  replace=FALSE, prob = indPhen_df$fitness[indPhen_df$subpop==i])
    subset <- c(subset, bob)
  }
  length(subset)
  head(subset)
  indPhen_df$subset <- FALSE
  indPhen_df$subset[sort((subset+1))] <- rep(TRUE, length(subset))
    # add one to subset here because indID starts at 0
  sum(indPhen_df$subset)
  # visualize all individuals
  boxplot(indPhen_df$fitness~indPhen_df$subpop, ylab = "fitness", xlab="pop", main="all", ylim=c(0,1))
  
  boxplot(indPhen_df$fitness[indPhen_df$subset]~indPhen_df$subpop[indPhen_df$subset], ylab = "fitness", xlab="pop", main="subset", ylim=c(0,1))
  # looks good to me
  
  all_corr_phen_sal <- cor(indPhen_df$phen_sal,indPhen_df$sal_opt)
  subsamp_corr_phen_sal <- cor(indPhen_df$phen_sal[indPhen_df$subset], indPhen_df$sal_opt[indPhen_df$subset])
  all_corr_phen_temp <- cor(indPhen_df$phen_temp,indPhen_df$temp_opt)
  subsamp_corr_phen_temp <- cor(indPhen_df$phen_temp[indPhen_df$subset],indPhen_df$temp_opt[indPhen_df$subset])
```


```{r show cool patterns of mutation}
plot(muts_df$mutSalEffect, muts_df$mutTempEffect, ylim=c(-0.7, 0.7), xlim=c(-0.7,0.7))
abline(h=0, col="grey")
abline(v=0, col="grey")
```


```{r filter VCF and reformat}
# This website has code I can recycle here
# https://github.com/TestTheTests/TTT_RecombinationGenomeScans/blob/master/src/b_Proc_Sims.R

head(muts_df)
dim(muts_df)
dim(vcf@gt)
head(vcf@gt[,1:5])

head(vcf@fix)

geno <- vcf@gt[,-1] 
position <- getPOS(vcf)

if (sum(duplicated(position)) != 0){
  print("This simulation has duplicated locus positions")
}

G <- matrix(NA, nrow = nrow(geno), ncol = ncol(geno))
G[geno %in% c("0/0", "0|0")] <- 0
G[geno  %in% c("0/1", "1/0", "1|0", "0|1")] <- 1
G[geno %in% c("1/1", "1|1")] <- 2

a_freq <- rowSums(G)/(2*ncol(G))
hist(a_freq)
```

```{r figure out mtuations to keep}
vcf_muts0 <- stringr::str_extract_all(vcf@fix[,"INFO"], "MID=(\\d*);", simplify=TRUE)
head(vcf_muts0)
vcf_muts1 <- sub("MID=", "", vcf_muts0)
vcf_muts <- as.numeric(sub(";", "", vcf_muts1))
head(vcf_muts)
keepmuts <- which(vcf_muts %in% muts_df$mutID)
head(keepmuts)
```

```{r VCF_FULL keepmuts}
geno_full <- vcf_full@gt[,-1] 
dim(geno_full)
position_full <- getPOS(vcf_full)
rown <- as.numeric(vcf_full@fix[,"ALT"]) # mutation ID
  # rown = 1 is a neutral mutation
keepmuts_full <- which(rown %in% muts_df$mutID) # causal mutations
position_full[keepmuts_full] # positions of causal mutations
```

```{r check vcf files line up}
dim(vcf@gt[keepmuts,])
dim(vcf_full@gt[keepmuts_full,])

if(!identical(as.numeric(position[keepmuts]), position_full[keepmuts_full]+1)){
  print("Error: positions in causal vcf vs. casual mutations in full vcf not the same")
}

if(!identical(vcf@gt[keepmuts,2], vcf_full@gt[keepmuts_full,2])){
   print("Error: genotypes in causal vcf vs. casual mutations in full vcf not the same")
}


if (!identical(sort(vcf_muts[keepmuts]), sort(muts_df$mutID))){
  print("Error: mutations in VCF not lining up with muts_df")
  break
}

```

The following code is for the subset VCF file of just causal mutations, subset to sampled individuals
```{r subset causal mutations MAF}
vcf_muts_subset <- vcf_muts[keepmuts]
muts_df$mutID

head(vcf@fix[keepmuts,], 50)

keepinds <- which(indPhen_df$subset)

dim(G)

G_subset <- G[keepmuts,keepinds]
dim(G_subset)
  # should have 1000 individuals

rownames(G_subset)=vcf_muts_subset
colnames(G_subset)=keepinds
G_subset[,1:10]

## This is my subset of individuals
length(keepinds)
subset_indPhen_df <- indPhen_df[keepinds,]

#cbind(vcf@gt[,2], G[,1])
#cbind(vcf@gt[keepmuts,2], G[keepmuts,1]) # looks good 
```





```{r sanity check individual phenotypes}

## ADD INFO FROM SLIM VCF FILE
vcf@fix[keepmuts,"INFO"]
head(muts_df)
dim(muts_df)
for (i in 1:nrow(muts_df)){
  ind = grep(muts_df$mutID[i], vcf@fix[,"INFO"])
  if (length(ind)==1){
    muts_df$INFO[i] <-  vcf@fix[ind,"INFO"]
    muts_df$position[i] <- position[ind]
    muts_df$af_slimVCF[i] <- a_freq[ind]
  }
}


## ADD INFO FROM PYSLIM VCF FILE
for (i in 1:nrow(muts_df)){
  ind = grep(muts_df$mutID[i], vcf_full@fix[,"ALT"])
  if (length(ind)==1){
    muts_df$position_pyslim[i] <- position_full[ind]
    muts_df$af_pyslim[i] <- a_freq_full[ind]
  }
}

head(muts_df)

plot(muts_df$af_slimVCF, muts_df$af_pyslim)
abline(0,1)
```

Keep in mind the correlations in the muts_df are based on the entire population
of 5000 individuals

The following code is for the subset VCF file of ALL mutations, subset to sampled individuals
```{r filter VCF_FULL and reformat}

head(geno_full[,1:5])


G_full <- matrix(NA, nrow = nrow(geno_full), ncol = ncol(geno_full))
G_full[geno_full %in% c("0/0", "0|0")] <- 0
G_full[geno_full  %in% c("0/1", "1/0", "1|0", "0|1")] <- 1
G_full[geno_full %in% c("1/1", "1|1")] <- 2

head(G_full[,1:5])

a_freq_full <- rowSums(G_full)/(2*ncol(G_full))
hist(a_freq_full)

if (!identical(sort(unique(unlist(as.numeric(G_full)))), as.numeric(0:2))){
  print("Error: full genotype matrix not uniquely 012")
  break
}

G_full_subset <- G_full[,keepinds]
dim(G_full_subset)
a_freq_subset <- rowSums(G_full_subset)/(2*ncol(G_full_subset))
  # should have 1000 individuals

# vcf_full@fix[,"POS"]

rownames(G_full_subset)=vcf_full@fix[,"POS"]
colnames(G_full_subset)=keepinds

## This is my subset of individuals
length(keepinds)

G_full_subset[1:20,1:10]
```

```{r set up full mutations table}
muts_full <- data.frame(seed = as.character(seed),
  VCFrow = 1:nrow(vcf_full@gt),
                        mutID = vcf_full@fix[,"ALT"],
                        pos_pyslim = as.integer(vcf_full@fix[,"POS"]),
                        a_freq_full = a_freq_full,
                        a_freq_subset = a_freq_subset)
dim(muts_full)

#THE CODE IS DOING WHAT I THINK IT SHOULD:
plot(muts_full$VCFrow, muts_full$pos_pyslim)

muts_full <- merge(muts_full, muts_df[,c("mutID", "mutSalEffect",
                                         "mutTempEffect", "INFO")], by="mutID", all.x=TRUE)
dim(muts_full)

head(muts_full)
head(muts_full[muts_full$mutID!=1,]) # causal mutations
plot(muts_full$VCFrow)

muts_full <- muts_full[order(muts_full$pos_pyslim),]
plot(muts_full$VCFrow)
plot(muts_full$VCFrow, muts_full$pos_pyslim)

muts_full$causal <- FALSE
muts_full$causal[muts_full$mutID!=1] <- TRUE
sum(muts_full$causal)
```

## This code estimates the AF and temp of each population
Used for calculation of the correlation and degree of cline
```{r af as function of temperature}
dim(G_full_subset)
str(indPhen_df[indPhen_df$subset,])

pop_temp <- data.frame(subpop=subset_indPhen_df$subpop,temp_opt=subset_indPhen_df$temp_opt)
pop_temp <- pop_temp[-which(duplicated(pop_temp)),]  
pop_temp
temp_levels <- unique(subset_indPhen_df$temp_opt)

af_temp <- matrix(NA, nrow=nrow(pop_temp), ncol=nrow(G_full_subset))

n_ind <- table(subset_indPhen_df$subpop)

muts_full$af_cor_temp <- NA
muts_full$af_slope_temp <- NA
muts_full$af_cor_temp_P <- NA
muts_full$af_cor_sal <- NA
muts_full$af_slope_sal <- NA
muts_full$af_cor_sal_P <- NA

for (row in 1:nrow(G_full_subset)){
    counts <- table(G_full_subset[row,], indPhen_df$subpop[indPhen_df$subset])
      # this give a table of the number of alleles for individuals at that temperature
    
    forSum <- counts*as.numeric(rownames(counts))
      # 0 for homozygote reference
      # 1 for heterozygote
      # 2 for homozygote derived
      # by multipling counts by number, heterozygotes are counted once
      # and homozygote derived are counted twice
      # also accounts for situations when only 2 genotypes found at a locus
  af_temp[,row] <- (colSums(forSum))/(2*n_ind)
  corrtemp <- cor.test(af_temp[,row], pop_temp$temp_opt, method="spearman")
  muts_full$af_cor_temp[row] <- corrtemp$estimate
  muts_full$af_cor_temp_P[row] <- corrtemp$p.value
  muts_full$af_slope_temp[row] <- lm(af_temp[,row]~pop_temp$temp_opt)$coef[2]
  
}
# this error message is common:
# 50: In cor.test.default(af_temp[, row], pop_temp$temp_opt,  ... :
#  Cannot compute exact p-value with ties

colnames(af_temp) <- muts_full$pos_pyslim
rownames(af_temp) <- pop_temp$temp_opt
dim(af_temp)

# Sanity check that what I calculate here (from the subsample)
# is similar to what I outputted from SliM in muts_df
par(mfrow=c(1,1))
bobx <- muts_full$af_cor_temp[which(muts_full$causal)]
boby<- muts_df$cor_temp[order(muts_df$position)]
plot(bobx, boby)
abline(0,1)




# these graphs do not account for linkage. It might help to have a neutral chromosome in the simulation I can use for comparison
ggplot(muts_full, aes(af_cor_temp, fill=causal)) + 
  geom_density(alpha=0.5) + xlab("Cor(p, temp)") + xlim(-1,1)

ggplot(muts_full, aes(af_slope_temp, fill=causal)) + 
  geom_density(alpha=0.5) + xlab("Slope(p, temp)") + xlim(-1,1)

muts_full$pos_pyslim <- as.integer(muts_full$pos_pyslim)

plot(muts_full$pos_pyslim, abs(muts_full$af_cor_temp))
points(muts_full$pos_pyslim[muts_full$causal], abs(muts_full$af_cor_temp[muts_full$causal]), col="blue", pch=20)

table(muts_full$af_cor_temp[muts_full$af_cor_temp>0.5 & muts_full$af_cor_temp<0.55])
```

WHY THE HORIZONAL LINE?
For some reason a bunch of loci have correlations in the range 0.521-0.522
```{r check}
nm <- which(muts_full$af_cor_temp>0.521 & muts_full$af_cor_temp<0.522)

af_temp[,nm[1:5]]

cor(af_temp[,nm[1]], pop_temp$temp_opt)
cor(af_temp[,nm[5]], pop_temp$temp_opt)

# it checks out. Seems to be driven by alleles present in only most extreme temp poopulation


# could improve by sampling 1000 neut and adding causal on top
# whats going on in neutral genome is weird...
for (i in 1:1000){
  af <- tapply(af_temp[,i], pop_temp$temp_opt, mean)
  if (i==1){
    plot(temp_levels, af, col=adjustcolor("blue", 0.1), type="l", ylim=c(0,1))
  }else{
    if (muts_full$causal[i]==TRUE){
      points(temp_levels, af, col="red", type="l", lwd=4)
      }else{
      points(temp_levels, af, col=adjustcolor("blue", 0.1), type="l", ylim=c(0,1))
    }
  }
}
head(muts_full$af_cor_temp)
```






## This code estimates the AF and salinity of each population
Used for calculation of the correlation and degree of cline
```{r af as function of salinity}
dim(G_full_subset)
str(indPhen_df[indPhen_df$subset,])

pop_sal <- data.frame(subpop=subset_indPhen_df$subpop,sal_opt=subset_indPhen_df$sal_opt)
pop_sal <- pop_sal[-which(duplicated(pop_sal)),]  
pop_sal
sal_levels <- unique(subset_indPhen_df$sal_opt)

af_sal <- matrix(NA, nrow=nrow(pop_sal), ncol=nrow(G_full_subset))

n_ind <- table(subset_indPhen_df$subpop)

muts_full$af_cor_sal <- NA
muts_full$af_slope_sal <- NA
muts_full$af_cor_sal_P <- NA
muts_full$af_cor_sal <- NA
muts_full$af_slope_sal <- NA
muts_full$af_cor_sal_P <- NA

for (row in 1:nrow(G_full_subset)){
    counts <- table(G_full_subset[row,], indPhen_df$subpop[indPhen_df$subset])
      # this give a table of the number of alleles for individuals at that salerature
    
    forSum <- counts*as.numeric(rownames(counts))
      # 0 for homozygote reference
      # 1 for heterozygote
      # 2 for homozygote derived
      # by multipling counts by number, heterozygotes are counted once
      # and homozygote derived are counted twice
      # also accounts for situations when only 2 genotypes found at a locus
  af_sal[,row] <- (colSums(forSum))/(2*n_ind)
  corrsal <- cor.test(af_sal[,row], pop_sal$sal_opt, method="spearman")
  muts_full$af_cor_sal[row] <- corrsal$estimate
  muts_full$af_cor_sal_P[row] <- corrsal$p.value
  muts_full$af_slope_sal[row] <- lm(af_sal[,row]~pop_sal$sal_opt)$coef[2]
  
}
# this error message is common:
# 50: In cor.test.default(af_sal[, row], pop_sal$sal_opt,  ... :
#  Cannot compute exact p-value with ties

colnames(af_sal) <- muts_full$pos_pyslim
rownames(af_sal) <- pop_sal$sal_opt
dim(af_sal)

# Sanity check that what I calculate here (from the subsample)
# is similar to what I outputted from SliM in muts_df
par(mfrow=c(1,1))
bobx <- muts_full$af_cor_sal[which(muts_full$causal)]
boby<- muts_df$cor_sal[order(muts_df$position)]
plot(bobx, boby)
abline(0,1)




# these graphs do not account for linkage. It might help to have a neutral chromosome in the simulation I can use for comparison
ggplot(muts_full, aes(af_cor_sal, fill=causal)) + 
  geom_density(alpha=0.5) + xlab("Cor(p, sal)") + xlim(-1,1)

ggplot(muts_full, aes(af_slope_sal, fill=causal)) + 
  geom_density(alpha=0.5) + xlab("Slope(p, sal)") + xlim(-1,1)

muts_full$pos_pyslim <- as.integer(muts_full$pos_pyslim)

plot(muts_full$pos_pyslim, abs(muts_full$af_cor_sal))
points(muts_full$pos_pyslim[muts_full$causal], abs(muts_full$af_cor_sal[muts_full$causal]), col="blue", pch=20)

```

This code looks at VA across metapopulation.
 * `prop_Va_metapop` proportion of VA explained by locus in metapopultion (this is a little misleading because some loci are low here, but explain a lot of VA in a specific environment)
  * `prop_Va_temp=1_sal=1`
  * `prop_Va_temp=1_sal=-1`
  * `prop_Va_temp=-1_sal=-1`
  * `prop_Va_temp=-1_sal=1`
  * `prop_Va_temp~0_sal=0`
  
```{r prop Va}

muts_full$Va_temp <- muts_full$a_freq_subset*(1-muts_full$a_freq_subset)*muts_full$mutTempEffect^2

muts_full$Va_temp_prop <- muts_full$Va_temp/sum(muts_full$Va_temp, na.rm=TRUE)
hist(muts_full$Va_temp_prop[which(muts_full$causal)])

muts_full$Va_sal <- muts_full$a_freq_subset*(1-muts_full$a_freq_subset)*muts_full$mutSalEffect^2

muts_full$Va_sal_prop <- muts_full$Va_sal/sum(muts_full$Va_sal, na.rm=TRUE)
hist(muts_full$Va_sal_prop[which(muts_full$causal)])

plot(muts_full$Va_temp_prop[which(muts_full$causal)],
     muts_full$Va_sal_prop[which(muts_full$causal)])
```


## LFMM


```{r lfmm ridge temp}

pcaG <- princomp(t(scaled.genotype))
plot(pcaG)
dim(pcaG$loadings)

### LFMM 0.0 Ridge regression model genotype ~ environment ####
# extract scaled genotypes
scaled.genotype <- scale(as.matrix(t(G_full_subset)))
#scaled.genotype <- as.matrix(t(sim1$G))
# extract scaled phenotypes
env_temp <- scale(as.matrix(subset_indPhen_df$temp_opt))
env_sal <- scale(as.matrix(subset_indPhen_df$sal_opt))
# ridge regression

phen_temp <- scale(as.matrix(subset_indPhen_df$phen_temp))
phen_sal <- scale(as.matrix(subset_indPhen_df$phen_sal))
```

ridge regression genotype-environment temp
```{r}
lfmm_ridge_ENVtemp <- lfmm::lfmm_ridge(Y = scaled.genotype, X = env_temp, K = 4, lambda = 1e-4)
#The lfmm.ridge object contains estimates for the latent variables and for the effect sizes. Here, the estimates are used for computing calibrated significance values and for testing associations between the response matrix Y and the explanatory variable x. It can be done as follows:
lfmm_ridge_ENVtemp_test  <- lfmm::lfmm_test(Y = scaled.genotype, X = env_temp, lfmm = lfmm_ridge_ENVtemp, calibrate = "gif")

lfmm_ridge_ENVtemp_P <- lfmm_ridge_ENVtemp_test$calibrated.pvalue

print(c("lfmm.test.ridge$gif", lfmm_ridge_ENVtemp_test$gif))
#hist(p.values.ridge, col = "lightgreen", main="LFMM ridge")
#qval <- qvalue::qvalue(p.values)
#plot(qval)
#The plot suggests that setting fdr.level = 0.025 warrant few false positives.
#qval <- qvalue::qvalue(p.values, fdr.level = 0.005)
#candidates <- which(qval$significant)
#plot(training$position, -log10(p.values.ridge), cex = .5, pch = 19, col = "black", main="LFMM ridge", ylim=c(0, 60))
#plot_layers(y_head=55, y_arrows=c(10, 0))

LFMM_ridge_ENVtemp_log10p <- -log10(as.numeric(lfmm_ridge_ENVtemp_P))
#plot(final_df$pos, final_df$LFMM_ridge_0.0_ALL_log10p) 

plot(muts_full$pos_pyslim, LFMM_ridge_ENVtemp_log10p)
points(muts_full$pos_pyslim[muts_full$causal], LFMM_ridge_ENVtemp_log10p[muts_full$causal], col="blue", pch=20)
```


ridge regression genotype-phenotype temp
```{r lfmm ridge temp phen}

lfmm_ridge_PHENtemp <- lfmm::lfmm_ridge(Y =  scaled.genotype, X = phen_temp, K = 4, lambda = 1e-4)
#The lfmm.ridge object contains estimates for the latent variables and for the effect sizes. Here, the estimates are used for computing calibrated significance values and for testing associations between the response matrix Y and the explanatory variable x. It can be done as follows:
lfmm_ridge_PHENtemp_test  <- lfmm::lfmm_test(Y = scaled.genotype, X = phen_temp, lfmm = lfmm_ridge_PHENtemp, calibrate = "gif")

lfmm_ridge_PHENtemp_P <- lfmm_ridge_PHENtemp_test$calibrated.pvalue

print(c("GIF", lfmm_ridge_PHENtemp_test$gif))
#hist(p.values.ridge, col = "lightgreen", main="LFMM ridge")
#qval <- qvalue::qvalue(p.values)
#plot(qval)
#The plot suggests that setting fdr.level = 0.025 warrant few false positives.
#qval <- qvalue::qvalue(p.values, fdr.level = 0.005)
#candidates <- which(qval$significant)
#plot(training$position, -log10(p.values.ridge), cex = .5, pch = 19, col = "black", main="LFMM ridge", ylim=c(0, 60))
#plot_layers(y_head=55, y_arrows=c(10, 0))

LFMM_ridge_PHENtemp_log10p <- -log10(as.numeric(lfmm_ridge_PHENtemp_P))
#plot(final_df$pos, final_df$LFMM_ridge_0.0_ALL_log10p) 

par(mar=c(4,4,1,1))
plot(muts_full$pos_pyslim, LFMM_ridge_PHENtemp_log10p)
points(muts_full$pos_pyslim[muts_full$causal], LFMM_ridge_PHENtemp_log10p[muts_full$causal], col="blue", pch=20)
```

```{r GWAS}
gwas_mut_slope <- NULL
gwas_mut_p <- NULL
gwas_mut_corrected_slope <- NULL
gwas_mut_corrected_p <- NULL

# this loop is slow but correct
for (i in 1:nrow(G_full_subset)){
  gwas_mut_i <- lm(G_full_subset[i,]~subset_indPhen_df$phen_temp)
  gwas_mut_slope[i] <- gwas_mut_i$coefficients[2]
  gwas_mut_p[i] <- summary(gwas_mut_i)$coefficients[2,4]
  
  gwas_mut_corrected_i <- lm(G_full_subset[i,]~subset_indPhen_df$phen_temp + pcaG$loadings[1,] + pcaG$loadings[2,])
  gwas_mut_corrected_slope[i] <- gwas_mut_corrected_i$coefficients[2]
  gwas_mut_corrected_p[i] <-  summary(gwas_mut_corrected_i)$coefficients[2,4]
}

plot(muts_full$pos_pyslim, -log10(gwas_mut_p))
plot(muts_full$pos_pyslim, -log10(gwas_mut_corrected_p))
points(muts_full$pos_pyslim[muts_full$causal],
      -log10(gwas_mut_corrected_p[muts_full$causal]), pch=20, col="magenta")

plot(LFMM_ridge_PHENtemp_log10p, -log10(gwas_mut_corrected_p))
points(LFMM_ridge_PHENtemp_log10p[muts_full$causal], -log10(gwas_mut_corrected_p)[muts_full$causal], col="magenta", pch=20)

plot(LFMM_ridge_ENVtemp_log10p, LFMM_ridge_PHENtemp_log10p)
points(LFMM_ridge_ENVtemp_log10p[muts_full$causal], LFMM_ridge_PHENtemp_log10p[muts_full$causal], col="magenta", pch=20)
```

```{r lfmm ridge sal}

env_sal <- scale(as.matrix(subset_indPhen_df$sal_opt))
# ridge regression

lfmm_ridge_sal <- lfmm::lfmm_ridge(Y = scaled.genotype, X = env_sal, K = 4, lambda = 1e-4)
#The lfmm.ridge object contains estimates for the latent variables and for the effect sizes. Here, the estimates are used for computing calibrated significance values and for testing associations between the response matrix Y and the explanatory variable x. It can be done as follows:
lfmm_ridge_sal_test  <- lfmm::lfmm_test(Y = scaled.genotype, X = env_sal, lfmm = lfmm_ridge_sal, calibrate = "gif")

lfmm_ridge_sal_P <- lfmm_ridge_sal_test$calibrated.pvalue

print(c("lfmm.test.ridge$gif", lfmm_ridge_sal_test$gif))
#hist(p.values.ridge, col = "lightgreen", main="LFMM ridge")
#qval <- qvalue::qvalue(p.values)
#plot(qval)
#The plot suggests that setting fdr.level = 0.025 warrant few false positives.
#qval <- qvalue::qvalue(p.values, fdr.level = 0.005)
#candidates <- which(qval$significant)
#plot(training$position, -log10(p.values.ridge), cex = .5, pch = 19, col = "black", main="LFMM ridge", ylim=c(0, 60))
#plot_layers(y_head=55, y_arrows=c(10, 0))

LFMM_ridge_sal_log10p <- -log10(as.numeric(lfmm_ridge_sal_P))
#plot(final_df$pos, final_df$LFMM_ridge_0.0_ALL_log10p) 

plot(muts_full$pos_pyslim, LFMM_ridge_sal_log10p)
points(muts_full$pos_pyslim[muts_full$causal], LFMM_ridge_sal_log10p[muts_full$causal], col="blue", pch=20)

plot(muts_full$Va_sal_prop, LFMM_ridge_sal_log10p)
plot(muts_full$Va_temp_prop, LFMM_ridge_ENVtemp_log10p)
```


## RDA

```{r vegan}
library(vegan)

plot(subset_indPhen_df$sal_opt, subset_indPhen_df$temp_opt)


subset_indPhen_df$x <- (unique(subset_indPhen_df$sal_opt)+1)*2
subset_indPhen_df$y <- round((unique(subset_indPhen_df$temp_opt)+1)*9/2,0)
m <- as.matrix(cbind(subset_indPhen_df$sal_opt, subset_indPhen_df$temp_opt))

rdaout <- rda(t(G_full_subset)~ subset_indPhen_df$sal_opt + subset_indPhen_df$temp_opt)

plot(rdaout)
str(rdaout)
scores <- scores(rdaout, choices=1:4)
loci.sc <- scores$species
ind.sc <- scores$sites
plot(loci.sc[,1], loci.sc[,2])
points(loci.sc[,1][muts_full$causal], 
       loci.sc[,2][muts_full$causal], 
       pch=20, col="magenta")

a<- screeplot(rdaout)
str(a)
a$y # save this it's the eigenvalues

plot(ind.sc[,1], ind.sc[,2])
eigenvals(rdaout)[1:2]
summary(rdaout)$biplot # add arrows


subset_indPhen_df$RDA1 <- ind.sc[,1]
subset_indPhen_df$RDA2 <- ind.sc[,2]

plot(scale(subset_indPhen_df$phen_temp) ~ scale(subset_indPhen_df$RDA1))


temp_pred_RDA <- subset_indPhen_df$RDA1*eigenvals(rdaout)[1]*summary(rdaout)$biplot[2,1] + subset_indPhen_df$RDA2*eigenvals(rdaout)[2]*summary(rdaout)$biplot[2,2]

plot(scale(subset_indPhen_df$phen_temp), scale(temp_pred_RDA))
abline(0,1)
  # predicted temperature phenotype is the RDA loading * eigenvalue of axis * loading of temperature on that axis


sal_pred_RDA <- subset_indPhen_df$RDA1*eigenvals(rdaout)[1]*summary(rdaout)$biplot[1,1] + subset_indPhen_df$RDA2*eigenvals(rdaout)[2]*summary(rdaout)$biplot[1,2]
plot(scale(subset_indPhen_df$phen_sal), scale(sal_pred_RDA))
abline(0,1)
  # predicted salinity phenotype is the RDA loading * eigenvalue of axis * loading of salinity on that axis


# Do locus loadings align with phenotypic effects
plot(muts_full$mutTempEffect, loci.sc[,1])
  cor.test(muts_full$mutTempEffect, loci.sc[,1])
plot(muts_full$mutSalEffect, loci.sc[,2])
  cor.test(muts_full$mutSalEffect, loci.sc[,2])
```

```{r}
rdadapt<-function(rda,K) {
zscores<-rda$CCA$v[,1:as.numeric(K)]
resscale <- apply(zscores, 2, scale)
resmaha <- covRob(resscale, distance = TRUE, na.action= na.omit, estim="pairwiseGK")$dis 
lambda <- median(resmaha)/qchisq(0.5,df=K)
reschi2test <- pchisq(resmaha/lambda,K,lower.tail=FALSE)
qval <- qvalue(reschi2test)
q.values_rdadapt<-qval$qvalues
return(data.frame(p.values=reschi2test, q.values=q.values_rdadapt))
}
ps <- rdadapt(rdaout, 2)

muts_full$rda_q <- ps$q.values
table(muts_full$causal, muts_full$rda_q<0.1)
```

```{r}
subset_indPhen_df$rand_env <- dmvnorm(m,
  mean=c(0,0), sigma=matrix(c(1, 0.5, 0.5, 1), ncol=2))
  # This is a saddle, I think 

subset_indPhen_df$rand_env2 <- dmvnorm(m,
  mean=c(1,1), sigma=matrix(c(1, 0, 0, 1), ncol=2))
  # This is like disease - it increases with salinity and temperature



plot(subset_indPhen_df$sal_opt,  subset_indPhen_df$temp_opt)
plot(subset_indPhen_df$sal_opt, subset_indPhen_df$rand_env)
plot(subset_indPhen_df$temp_opt, subset_indPhen_df$rand_env)
plot(subset_indPhen_df$sal_opt, subset_indPhen_df$rand_env2)
plot(subset_indPhen_df$temp_opt, subset_indPhen_df$rand_env2)

rdaout <- rda(t(G_subset)~ subset_indPhen_df$sal_opt + subset_indPhen_df$temp_opt + subset_indPhen_df$rand_env + subset_indPhen_df$rand_env2)
summary(rdaout)
screeplot(rdaout)
plot(rdaout)
scores <- scores(rdaout, choices=1:4)
loci.sc <- scores$species
ind.sc <- scores$sites
head(loci.sc)
head(ind.sc)
str(loci.sc)

plot(loci.sc[,1], loci.sc[,2])

head(subset_indPhen_df)
subset_indPhen_df$RDA1 <- ind.sc[,1]
subset_indPhen_df$RDA2 <- ind.sc[,2]
subset_indPhen_df$RDA3 <- ind.sc[,3]
plot(subset_indPhen_df$temp_opt ~ subset_indPhen_df$RDA1)
plot(scale(subset_indPhen_df$phen_temp) ~ scale(subset_indPhen_df$RDA1))
abline(0,1, col="red")

plot(subset_indPhen_df$sal_opt ~ subset_indPhen_df$RDA2)
plot(subset_indPhen_df$phen_sal ~ subset_indPhen_df$RDA2)

p <- subset_indPhen_df$RDA2*0.53*0.41 + subset_indPhen_df$RDA3*0.84*0.29
  # predicted salinity phenotype is the RDA loading * eigenvalue of axis * loading of salinity on that axis
plot(subset_indPhen_df$sal_opt ~ p)
plot(scale(subset_indPhen_df$phen_sal) ~ scale(p))
abline(0,1, col="red")
```










```{r}
alpha <- 0.05/nrow(muts_all)
sig_temp <- muts_all$af_cor_temp_P<alpha
sig_sal <- muts_all$af_cor_sal_P<alpha

# Percent of VA explained by clinal patterns (e.g. sig. correlations)
sum(muts_all$Va_temp_prop[sig_temp]) # sanity check
sum(muts_all$Va_sal_prop[sig_sal]) # sanity check

sum(sig_temp) # number significant 
sum(sig_sal) # number significant

sum(sig_temp/nrow(muts_all))
sum(sig_sal/nrow(muts_all))

muts_all$FalseNegCorType <- NA
muts_all$FalseNegCorType[!sig_temp & !sig_sal] <- "Both_FN"
muts_all$FalseNegCorType[sig_temp & !sig_sal] <- "Temp_TP_Sal_FN"
muts_all$FalseNegCorType[!sig_temp & sig_sal] <- "Temp_FN_Sal_TP"
muts_all$FalseNegCorType[sig_temp & sig_sal] <- "Both_TP"

table(muts_all$FalseNegCorType)/nrow(muts_all)

# some visualization
plot(abs(muts_all$Va_temp_prop), abs(muts_all$af_slope_temp))
plot(abs(muts_all$Va_temp_prop), abs(muts_all$af_cor_temp))

plot(abs(muts_all$Va_sal_prop), abs(muts_all$af_slope_sal))
plot(abs(muts_all$Va_sal_prop), abs(muts_all$af_cor_sal))

hist(vcf_muts_df$af_cor_temp)
hist(vcf_muts_df$af_cor_sal)

hist(abs(vcf_muts_df$af_cor_temp))
hist(abs(vcf_muts_df$af_cor_sal))

hist(abs(vcf_muts_df$af_slope_temp))
hist(abs(vcf_muts_df$af_slope_sal))
```


## This code estimates the AF of all populations at the same temp/sal
Used for plotting
```{r af as function of salinity}

sal_levels <- unique(subset_indPhen_df$sal_opt)
sal_levels
af_sal <- matrix(NA, nrow=length(sal_levels), ncol=nrow(G_subset))
n_ind <- table(indPhen_df$sal_opt[indPhen_df$subset])

vcf_muts_df$af_cor_sal = NA

for (row in 1:nrow(G_subset)){
    counts <- table(G_subset[row,], indPhen_df$sal_opt[indPhen_df$subset])
      # this give a table of the number of alleles for individuals at that salinity
    
    forSum <- counts*as.numeric(rownames(counts))
      # 0 for homozygote reference
      # 1 for heterozygote
      # 2 for homozygote derived
      # by multipling counts by number, heterozygotes are counted once
      # and homozygote derived are counted twice
      # also accounts for situations when only 2 genotypes found at a locus
  af_sal[,row] <- (colSums(forSum))/(2*n_ind)
  vcf_muts_df$af_cor_sal[row] <- cor(af_sal[,row], sal_levels)

}

colnames(af_sal) <- vcf_muts_subset
rownames(af_sal) <- sal_levels
head(af_sal)

# Sanity check that what I calculate here (from the subsample)
# is similar to what I outputted from SliM in muts_df
plot(vcf_muts_df$af_cor_sal[order(vcf_muts_df$mutID)],
     muts_df$cor_sal[order(muts_df$mutID)])
abline(0,1)

hist(vcf_muts_df$af_cor_sal)
```


# Plot phenotype vs. AF clines

1st column:
Phenotypic clines for temp (top) and salinity (bottom)

2nd column:
AF clines for temp (top) and salinity (bottom)

```{r}

subset_indPhen_df$phen_temp


  par(mfrow=c(2,2), mar=c(4,6,0.5,0.5))

  cond <- indPhen_df$subset

  plot(indPhen_df$temp_opt[cond], indPhen_df$phen_temp[cond], xlab="Deme\nTemperature", ylab="Individual optimum\ntemperature",pch=18, , las=1, bty="n", col=adjustcolor("purple",0.1))
  abline(lm(indPhen_df$phen_temp[cond]~indPhen_df$temp_opt[cond]))
    
  plot(jitter(indPhen_df$sal_opt[cond]), indPhen_df$phen_sal[cond],
       xlab="Deme\nSalinity", ylab="Individual optimum\nsalinity", pch=20, col=adjustcolor("blue",0.1), las=1, bty="n"
       )
  abline(lm(indPhen_df$phen_sal[cond]~indPhen_df$sal_opt[cond]))
  
 
```



```{r make af vs. temp plot}
pdf("tempAF.pdf", width=4, height=2)
par(mar=c(4,4,1,4))
plot(temp_af$Temp, rep(0, length(temp_af$Temp)), ylim=c(0,1), xlab="Temperature", ylab="Allele frequency", col=rgb(0,0,0,0), bty="n")

head(temp_af)

#viridis(10)
col <- two.colors(10, "#3B528BFF", "#FDE725FF", middle = "#6DCD59FF")
for (i in 1:ncol(af_temp)){
  cor_mut <- cor(temp_af$Temp, af_temp[,i])
  if(abs(cor_mut)<0.3){lwd=2}else{lwd=1}
  lines(temp_af$Temp, af_temp[,i], col=col[round(abs(cor_mut),1)*10], lwd=lwd)
}
legend.col(col, lev=seq(0,1,by=0.1))
dev.off()
```



```{r make af vs. sal plot}
pdf("SalAF.pdf", width=4, height=2)
par(mar=c(4,4,1,4))
plot(sal_af$Sal, rep(0, length(sal_af$Sal)), ylim=c(0,1), xlab="Salinity", ylab="Allele frequency", col=rgb(0,0,0,0), bty="n")
#viridis(10)
col <- two.colors(10, "#3B528BFF", "#FDE725FF", middle = "#6DCD59FF")
for (i in 1:ncol(af_sal)){
  cor_mut <- cor(sal_af$Sal, af_sal[,i])
  if(abs(cor_mut)<0.3){lwd=2}else{lwd=1}
  lines(sal_af$Sal, af_sal[,i], col=col[round(abs(cor_mut),1)*10], lwd=lwd)
}
legend.col(col, lev=seq(0,1,by=0.1))
dev.off()
```

```{r genotype heatmaps}

NEED TO EDIT THISE SO THE GRAPHING IS 3 colors

order_temp <- order(subset_indPhen_df$phen_temp)
heatmap(t(G_subset[,order_temp]), Rowv = NA,  main="All genotypes",cexCol = 0.3,
           #Colv = NA,
           labRow = round(subset_indPhen_df$phen_temp[order_temp],1))


a<-heatmap(t(G_subset), Rowv = NA,  main="All genotypes",cexCol = 0.3,
           #Colv = NA,
           labRow = indPhen_df$subpop[keepinds])
str(a)
par(mfrow=c(1,1), oma=c(0,0,0,0), mar=c(2,4,6,2), xpd=FALSE)

### Visualize genotypes at different salinities ###
new=subset_indPhen_df$sal_opt

heatmap(t(G_subset[a$colInd,new==-1]), Rowv = NA, Colv = NA, 
        main="Low salinity genotypes", 
        labRow = subset_indPhen_df$subpop[new==-1],
        xlab="Mutation ID",  cexCol = 0.3, #labCol = a$colInd,
        ylab="Southern<---Population--->Northern")
  # this is cool. The low salinity sites, which are not connected by dispersal, evolve unique and different adaptations to salinity

heatmap(t(G_subset[a$colInd,new==0]), Rowv = NA, Colv = NA, 
        main="Intermediate salinity\ngenotypes", 
        labRow = subset_indPhen_df$subpop[new==0],
        xlab="Mutation ID",  cexCol = 0.3, #labCol = a$colInd,
        ylab="Southern<---Population--->Northern")
  # 

heatmap(t(G_subset[a$colInd,new==1]), Rowv = NA,  Colv = NA,
        main="High salinity genotypes",
        labRow = subset_indPhen_df$subpop[new==1],
         xlab="Mutation ID",  cexCol = 0.3, 
        ylab="Southern<---Population--->Northern")
  # The high salinity sites, which are connected by dispersal, evolve a more clinal allele frequency pattern with salinity
```



```{r NOT USING}
### Visualize genotypes at different temps ####
new_temp=subset_indPhen_df$temp_opt

#northern pops
heatmap(t(G_subset[a$colInd,new_temp==1]), Rowv = NA,  Colv = NA,
        main="High temp (north) genotypes",
        labRow = subset_indPhen_df$subpop[new_temp==1],
        xlab="Mutation ID",  cexCol = 0.3, 
        ylab="Low Sal<---Population--->High Sal")

heatmap(t(G_subset[a$colInd,new_temp==-0.111111]), Rowv = NA,  Colv = NA,
        main="Mid-latitude genotypes",
        labRow = subset_indPhen_df$subpop[new_temp==-0.111111],
        xlab="Mutation ID",  cexCol = 0.3,  
        ylab="Low Sal<---Population--->High Sal")

heatmap(t(G_subset[a$colInd,new_temp==-1]), Rowv = NA,  Colv = NA,
        main="Low temp (south) genotypes",
        labRow = subset_indPhen_df$subpop[new_temp==-1],
        xlab="Mutation ID",  cexCol = 0.3, 
        ylab="Low Sal<---Population--->High Sal")

```


```{r}

X <- t(G_subset)
Y <- cbind(indPhen_df$sal_opt[which(indPhen_df$subset)], indPhen_df$temp_opt[which(indPhen_df$subset)])
str(X)
str(Y)


set.seed(12380923)
rm <- sort(sample(indPhen_df$indID[-keepinds], 200, replace=FALSE)) # 200 random individuals
head(cbind(indPhen_df$indID[rm+1], rm))
rm <- rm+1 # because individuals start at 0, this can be an index now
indPhen_df$test <- FALSE
indPhen_df$test[rm] <- TRUE

indPhen_df[which(indPhen_df$subset & indPhen_df$test),]
  # shows no overlap

# unit test - make sure test and train individuals do not overlap
if (sum((indPhen_df$subset & indPhen_df$test))){
  print("Error: overlap in subset and test set")}

test_indPhen_df <- indPhen_df[rm,]

trainX <- X
trainY <- Y
testX <- t(G[keepmuts, rm])
testY_true <- cbind(indPhen_df$sal_opt[rm], indPhen_df$temp_opt[rm])
dim(testY_true)
testXsampName <- test_indPhen_df$indID

```


NEED TO EDIT THIS
```{r show cool patterns of fitness, fig.height=6, fig.width=4}
head(indPhen_df)
env_df <- unique(indPhen_df[,c("subpop","sal_opt","temp_opt")])
head(env_df)
(npops <- nrow(indCG_df)-1)

# choose an individual who has high fitness at cold end of range
# and in low salinity sites
head(indCG_df[,1:20], 10)
tail(indCG_df[,1:20], 10)

env_df$ind1_fit <- indCG_df[2:nrow(indCG_df), 1]
env_df$ind1_pch <- c(0,22)

# choose an individual who has high fitness at warm end of range
# and in low salinity sites
tail(indCG_df[,(ncol(indCG_df)-10):ncol(indCG_df)], 10)
env_df$ind2_fit <- indCG_df$V2000[2:nrow(indCG_df)]
env_df$ind2_pch <- c(1,21)

# choose an individual who has high fitness at cold end of range
# and in HIGH salinity sites
head(indCG_df[,101:120], 10)
env_df$ind3_fit <- indCG_df$V107[2:nrow(indCG_df)]
env_df$ind3_pch <- c(0,22)

# choose an individual who has high fitness at warm end of range
# and in HIGH salinity sites
tail(indCG_df[,(ncol(indCG_df)-10):ncol(indCG_df)], 10)
env_df$ind4_fit <- indCG_df$V1994[2:nrow(indCG_df)]
env_df$ind4_pch <- c(1,21)

### Start plot ####
par(mar=c(2,4,3,0.1), mfrow=c(2,1), oma=c(4,0,0,0))
### Plot low salinity adapted ####
  plot(env_df$temp_opt,env_df$ind1_fit, pch=env_df$ind1_pch, 
       col="blue", bg="grey", bty="l", las=1, ylim=c(0,1),
       xlab="", ylab="fitness", main="Low salinity adapted")
    points(ind1_fit~temp_opt, type="l", data=env_df, col=adjustcolor("blue",0.4))
    text(-1,1.08,"Ind. A", col="blue", adj=0)
  
  points(env_df$temp_opt,env_df$ind2_fit, pch=env_df$ind2_pch, col="red", bg="grey") 
  points(env_df$temp_opt,env_df$ind2_fit, pch=env_df$ind2_pch, col=adjustcolor("red", 0.2), type="l")
  text(0.6,1.08,"Ind. B", col="red", adj=0)
  
### Plot high salinity adapted ####
  plot(env_df$temp_opt,env_df$ind3_fit, pch=env_df$ind3_pch, 
       col="blue", bg="grey", bty="l", las=1, ylim=c(0,1),
       xlab="", ylab="fitness", main="High salinity adapted")
    points(ind3_fit~temp_opt, type="l", data=env_df, col=adjustcolor("blue",0.4))
    text(-1,1.08,"Ind. C", col="darkblue", adj=0)
  
  points(env_df$temp_opt,env_df$ind4_fit, pch=env_df$ind4_pch, col="red", bg="grey") 
  points(env_df$temp_opt,env_df$ind4_fit, pch=env_df$ind4_pch, col=adjustcolor("red", 0.2), type="l")
  text(0.6,1.08,"Ind. D", col="darkred", adj=0)

### Plot legend
par(xpd=NA)  
legend(-1,-0.4,  legend=c("high sal.", "low sal."), bty="n", adj=0, fill=c("grey", NA), horiz=TRUE)
mtext("temperature", side=1, outer=TRUE, adj=0.6)
```

