import pyslim, msprime
import numpy as np
import random
import time
import re
import ast
import sys
import os

parser = argparse.ArgumentParser()
parser.add_argument("-s", "--seed", required = True)
parser.add_argument("-r", "--recom", required = True)
parser.add_argument("-N", "--NperPop", required = True)
parser.add_argument("-mu", "--mutate", required = True)

args = vars(parser.parse_args())
seed = args['seed']
r = args['recom']
N = args['NperPop']
mu = args['mutate']
seednum = round(int(seed)**(1/2)) # slim seeds are too large

# Load the .trees file
T2 = pyslim.load("../sim_outputs/" + seed + ".trees")


print(f"The tree sequence has {T2.num_trees} trees on a genome of length {T2.sequence_length},"
      f" {T2.num_individuals} individuals, {T2.num_samples} 'sample' genomes,"
      f" and {T2.num_mutations} mutations.")

#Is recapitation necessary? How many trees have more than one root?
sum([t.num_roots != 1 for t in T2.trees()])
	# If this is a non-zero number then you need to recaptitate
	
#Open the migration matrix (generated by SLiM code)
with open('../sim_outputs/' + str(seed) + '_mig_mat.txt') as infile:
    data = infile.read()

#Save migration matrix as 'mig_mat'
mig_mat = []
for i in re.findall(r"(\[.*?\])", data, flags=re.S):
    mig_mat.append(ast.literal_eval(i))


#Time how long it takes to recapitate the TSR file
start = time.time()
recapT2 = T2.recapitate(recombination_rate = r, migration_matrix=mig_mat, Ne=N, random_seed=seednum) #Ne is multiplied by the number of populations in the file
end = time.time()
print("Time it took to to recapitate:", end - start)



#Add mutations to the recapitated tree
mutatedT2 = pyslim.SlimTreeSequence(msprime.mutate(recapT2, rate=mu, random_seed=seednum, keep=True))

print(f"The tree sequence now has {mutatedT2.num_trees} trees,"
      f" and {mutatedT2.num_mutations} mutations.")
      

with open("../sim_outputs/" + str(seed) + "_PlusNeuts.vcf", "w") as vcf_file:
    mutatedT2.write_vcf(vcf_file)



# Calculate tree heights, giving uncoalesced sites the maximum time
def tree_heights(ts):
    heights = np.zeros(ts.num_trees + 1)
    for tree in ts.trees():
        if tree.num_roots > 1: # not fully coalesced
            heights[tree.index] = ts.slim_generation
        else:
            children = tree.children(tree.root)
            real_root = tree.root if len(children) > 1 else children[0]
            heights[tree.index] = tree.time(real_root)
    heights[-1] = heights[-2] # repeat the last entry for plotting
    return heights
 
# Plot tree hieghts after recapitation
# breakpoints = list(recap.breakpoints())
# heights = tree_heights(recap)
# plt.step(breakpoints, heights, where='post')

# Plot tree heights before recapitation
# breakpoints1 = list(ts.breakpoints())
# heights1 = tree_heights(ts)
# plt.step(breakpoints1, heights1, where='post')
# plt.show()
