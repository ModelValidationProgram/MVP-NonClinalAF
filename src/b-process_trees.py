import pyslim, msprime, argparse
import numpy as np
import random
import time
import re
import ast
import sys
import os

#seed = '2242330863068'
#r = 1e-6
#N = 100
#mu = 1e-7
#gen = 3000

parser = argparse.ArgumentParser()
parser.add_argument("-s", "--seed", required = True)
parser.add_argument("-r", "--recom", required = True, type=float)
parser.add_argument("-N", "--NTot", required = True, type=int)
parser.add_argument("-mu", "--mutate", required = True, type=float)
parser.add_argument("-o", "--output", required = True, type=str) 

args = vars(parser.parse_args())
seed = args['seed']
r = args['recom']
N = args['NTot']
mu = args['mutate']
output = args['output']
seednum = round(int(seed)**(1/2)) # slim seeds are too large

# Load the .trees file
T2 = pyslim.load(output + seed + ".trees")

print(f"The tree sequence has {T2.num_trees} trees on a genome of length {T2.sequence_length},"
      f" {T2.num_individuals} individuals, {T2.num_samples} 'sample' genomes,"
      f" and {T2.num_mutations} mutations.")

#Is recapitation necessary? How many trees have more than one root?
sum([t.num_roots != 1 for t in T2.trees()])
	# If this is a non-zero number then you need to recaptitate
	
#Open the migration matrix (generated by SLiM code)
with open(output + str(seed) + '_mig_mat.txt') as infile:
    data = infile.read()

#Save migration matrix as 'mig_mat'
mig_mat = []
for i in re.findall(r"(\[.*?\])", data, flags=re.S):
    mig_mat.append(ast.literal_eval(i))


#Time how long it takes to recapitate the TSR file
start = time.time()
recapT2 = T2.recapitate(recombination_rate = r, migration_matrix=mig_mat, Ne=N, random_seed=seednum) #Ne is multiplied by the number of populations in the file
end = time.time()
print("Time it took to to recapitate:", end - start)



#Add mutations to the recapitated tree
mutatedT2 = pyslim.SlimTreeSequence(msprime.mutate(recapT2, rate=mu, random_seed=seednum, keep=True))

print(f"The tree sequence now has {mutatedT2.num_trees} trees,"
      f" and {mutatedT2.num_mutations} mutations.")
 
mutatedT2.metadata['SLiM']['generation']
mutatedT2.slim_generation
mutatedT2.metadata['SLiM']['stage']
mutatedT2.slim_time(0)

 
 # Below is some of Aki's code for outputing individual information
 # I don't need this because I only output tree sequences at one time point
 
# Add individual IDs     
# T2ind = mutatedT2.individuals_alive_at(0)    
# # 
# # 
# indivlist_T2 = []
# indivnames_T2 = []
# # 
# # 
# with open("../sim_outputs/"+str(seed)+"_tree_individuals.txt", "w") as indfile:
#     indfile.writelines("\t".join(["vcf_label", "tskit_id", "slim_id"] + ["birth_time_ago", "age"]) + "\n")
#     for i in T2ind:
#         indivlist_T2.append(i)
#         ind = T2.individual(i)
#         vcf_label = f"{ind.metadata.pedigree_id}"
#         indivnames_T2.append(vcf_label)
#         data = [vcf_label, str(ind.id), str(ind.metadata.pedigree_id), str(ind.time),str(ind.metadata.age)]
#         indfile.writelines("\t".join(data) + "\n")
     
# this takes a subset if needed
#with open("../sim_outputs/"+str(seed)+"_subset_T2.txt", "w") as indfile:
#    indfile.writelines("vcf_label" + "\n")
#    Start = np.arange(0,10001,100)
#    Stop = np.arange(100,10001,100)
#    for i in range(0, (len(Start)-1)):
#      samp = random.sample(indivnames_T2[Start[i]:Stop[i]],10)
#      indfile.writelines("\n".join(samp) + "\n")

  

with open(output + str(seed) + "_PlusNeuts.vcf", "w") as vcf_file:
    #mutatedT2.write_vcf(vcf_file, individuals=indivlist_T2, individual_names=indivnames_T2)
	mutatedT2.write_vcf(vcf_file)


# Calculate tree heights, giving uncoalesced sites the maximum time
def tree_heights(ts):
    heights = np.zeros(ts.num_trees + 1)
    for tree in ts.trees():
        if tree.num_roots > 1: # not fully coalesced
            heights[tree.index] = ts.slim_generation
        else:
            children = tree.children(tree.root)
            real_root = tree.root if len(children) > 1 else children[0]
            heights[tree.index] = tree.time(real_root)
    heights[-1] = heights[-2] # repeat the last entry for plotting
    return heights
 
# Plot tree hieghts after recapitation
# breakpoints = list(recap.breakpoints())
# heights = tree_heights(recap)
# plt.step(breakpoints, heights, where='post')

# Plot tree heights before recapitation
# breakpoints1 = list(ts.breakpoints())
# heights1 = tree_heights(ts)
# plt.step(breakpoints1, heights1, where='post')
# plt.show()
