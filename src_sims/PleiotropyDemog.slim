initialize()
{
	setSeed(22423308670);
	defineConstant("MY_RESULTS_PATH","/Users/lotterhos/Documents/GitHub/MVP-NonClinalAF/sim_outputs/");
	defineConstant("MY_SEED", getSeed());
	defineConstant("C_num", 20);							// number of chromosomes
	defineConstant("C_lengths", rep(50000, C_num));	// lengths for each chromosome
	defineConstant("MU_base", 1e-7);						// base mutation rate overall
	defineConstant("MU_QTL_proportion", 0.02);		
	defineConstant("MU", MU_base * MU_QTL_proportion);	// mut rate for QTNs specifically
	defineConstant("R", 1e-6);								// recombination rate

	defineConstant("MIG_x", 0.49);	 //0.49						// migration rate between subpops
	defineConstant("MIG_y", 0.01);	//0.01						// migration rate between subpops
		// requires isVariableM = 0		
		// if isVariableM = 1, these are ignored
		
	defineConstant("MIG_breaks", 0); // 0 means no biogeographic breaks
		// a value of 1 introduces 2 biogeographic breaks

	
	defineConstant("xcline", "linear"); // cline in x trait. Other option is "V"
	defineConstant("ycline", "linear");// cline in y trait. Other option is "V"
	
	defineConstant("N_traits", 1);   // number of traits (1 or 2)
	defineConstant("ispleiotropy", 1); // a value of 0 for no pleiotropy, 1 for pleitropy
	defineConstant("iscontrol", 0); // a value of 0 for stabilizing selection
	defineConstant("demog", "SS");
		// "Estuary" for estuary demography
		// "SS" for stepping stone demography
	defineConstant("Nequal", 0); // 0 for equal N, 1 for N cline on x-axis, 2 for N cline on y-axis, 3 for variable N, 4 for N largest in range center
	// NOTE: the variable N only works for grids of length 10
	defineConstant("isVariableM", 0); // 0 for equal m, 1 for variable m
	
	if (Nequal == 0){
		defineConstant("N", 100);								// subpop size
	}
	if (Nequal == 1 | Nequal == 2 | Nequal == 3){
		defineConstant("N", c(10,10,50,50,95,95,145,145,200,200));	
	}
	if (Nequal == 4){
		//defineConstant("N", c(10,50,95,145,200, 200, 145, 95, 50, 10));	
		// see below
	}
	

	defineConstant("BURNIN_1", 1000);						// number of burning generations
	defineConstant("BURNIN_2", 2000);						// generation when selection stabilizes
	defineConstant("TOTAL_GEN", 3000);						// number of burning generations
	defineConstant("METAPOP_SIDE_x", 10);			// number of subpops
		// this should stay equal to metapop_side_y for now
	defineConstant("METAPOP_SIDE_y", 10);			// number of subpops
	//defineConstant("S", 0.1);								// selection coefficient for local fitness gradient (not used in this sim)
	defineConstant("SIGMA_K_1", 0.5);						// smaller is stronger stabilizing selection, // larger is weaker (wider) stabilizing selection for trait 1
	defineConstant("SIGMA_K_2", 0.5);						// smaller is stronger stabilizing selection, // larger is weaker (wider) stabilizing selection for trait 2
	defineConstant("SIGMA_K_Cov", 0);						// covariance in stabilizing selection
	defineConstant("SIGMA_QTN_1", 0.1);			// standard deviation of mutational effect size - for trait 1
	defineConstant("SIGMA_QTN_2", 0.1);			// standard deviation of mutational effect size - for trait 2
	defineConstant("SIGMA_QTN_Cov", 0);			// covariance in mutation effect size (e.g. if negative, mutations that tend to have a positive effect on one trait, have a negative effect on the other)

	defineConstant("SIGMA_STAT", 4.0);					// burn-in stabilizing selection function variance
	defineConstant("METAPOP_NPOPS", METAPOP_SIDE_x * METAPOP_SIDE_y);
	
	// set up spatially autocorrelated environmental variables
	defineConstant("xl", rep(seq(-1.0, 1.0, length=METAPOP_SIDE_x), METAPOP_SIDE_y)); // salinity
	defineConstant("yl", repEach(seq(-1.0, 1.0, length=METAPOP_SIDE_y), METAPOP_SIDE_x)); // temperature
	defineConstant("v", seq(-1.0, 1.0, length=integerDiv(METAPOP_SIDE_x,2)));
	defineConstant("v2", c(v,v[(length(v)-1):0]));
	defineConstant("xv", rep(v2, METAPOP_SIDE_y)); // salinity
	defineConstant("yv", repEach(v2, METAPOP_SIDE_x)); // temperature

	if (xcline=="linear"){
	defineConstant("OPTS_0", xl); 
	}
	if (ycline=="linear"){
	defineConstant("OPTS_1", yl);
	}
	if (xcline=="V"){
	defineConstant("OPTS_0", xv); 
	}
	if (ycline=="V"){
	defineConstant("OPTS_1", yv);
	}
	
	
	
	//initializeTreeSeq(simplificationInterval=500);	// infrequent for faster runtimes
	initializeTreeSeq();
	initializeMutationRate(MU);
	initializeSex("A"); //Set each population to contain two autosomal sexes that must reproduce to yield next generation
	
	//initializeMutationType("m1", 0.5, "f", 0.0); // Neutral
	initializeMutationType("m2", 0.5, "f", 0.0); // QTL mutations under selection across the environment
	m2.convertToSubstitution = F;
	
	initializeGenomicElementType("g1", m2, 1.0);
	initializeGenomicElement(g1, 0, sum(C_lengths[0:(C_num - 10)]));
	
	rates = c(rep(c(R, 0.5), C_num-1), R);
	ends = repEach(cumSum(C_lengths), 2);
	ends = ends[0:(length(ends) - 2)];
	ends = ends + c(rep(c(0,1), C_num-1), 0);
	initializeRecombinationRate(rates, ends);
	
	// QTL-related constants used below
	defineConstant("QTL_mu", c(0, 0));
	defineConstant("QTL_sigma", matrix(c(SIGMA_QTN_1, SIGMA_QTN_Cov, SIGMA_QTN_Cov, SIGMA_QTN_2), nrow=2));
	
	catn();
	catn("QTL DFE means: ");
	print(QTL_mu);
	catn();
	catn("QTL DFE variance-covariance matrix: ");
	print(QTL_sigma);
}
//METAPOP_SIDE by METAPOP_SIDE matrix of populations
function (void)setUpMigration(void)
{
	subpops = sim.subpopulations;
	
	if (demog=="Estuary"){
	for (x in 1:METAPOP_SIDE_x)
		{
		for (y in 1:METAPOP_SIDE_y)
		{
			destID = (x - 1) + (y - 1) * METAPOP_SIDE_x + 1;
				// when x = 1, this gives an odd number (y = 1,2,3 gives destID=1,3,5)
				// when x = 2, this gives an even number (y = 1,2,3 gives destID=2,4,6)
			destSubpop = subpops[destID - 1];
			if (x > 1) // Left to right
			{ 
				if (isVariableM ==0)
				{
					destSubpop.setMigrationRates(destID - 1, MIG_x);
				}
				if (isVariableM ==1)
				{
					destSubpop.setMigrationRates(destID - 1, sample(c(0.001,0.01,0.1,0.25), 1));
				}
			}
			if (x < METAPOP_SIDE_x) // Right to left
			{
				if (isVariableM == 0)
				{
					destSubpop.setMigrationRates(destID + 1, MIG_x);
				}
				if (isVariableM == 1)
				{
					destSubpop.setMigrationRates(destID + 1, sample(c(0.001,0.01,0.1,0.25), 1));
				}
			}
			if (x == METAPOP_SIDE_x)
			{
				if (y > 1) // Top to bottom 
				{
					if (isVariableM == 0)
					{
						destSubpop.setMigrationRates(destID - METAPOP_SIDE_x, MIG_y);
					}
					if (isVariableM == 1)
					{
						destSubpop.setMigrationRates(destID - METAPOP_SIDE_x, sample(c(0.001,0.01,0.1,0.25), 1));
					}
					if (MIG_breaks ==1){
						if (destID <= 50 & destID >= 41){
						destSubpop.setMigrationRates(destID - METAPOP_SIDE_x, 0.0001);
						}
						if (destID <= 80 & destID >= 71){
						destSubpop.setMigrationRates(destID - METAPOP_SIDE_x, 0.0001);
						}
					}
					
				}
				if (y < (METAPOP_SIDE_y-1)) // Bottom to top 
					//print(destSubpop);
				{
					if (isVariableM == 0)
					{
					destSubpop.setMigrationRates(destID + METAPOP_SIDE_x, MIG_y);
					}
					if (isVariableM == 1)
					{
					destSubpop.setMigrationRates(destID + METAPOP_SIDE_x, sample(c(0.001,0.01,0.1,0.25), 1));
					}
					
					if (MIG_breaks ==1){
						if (destID <= 40 & destID >= 31){
						destSubpop.setMigrationRates(destID - METAPOP_SIDE_x, 0.0001);
						}
						if (destID <= 70 & destID >= 61){
						destSubpop.setMigrationRates(destID - METAPOP_SIDE_x, 0.0001);
						}
					}
				}
			} // end if (x == METAPOP_SIDE_x)
			//if (x==2 & y==1)
			//	subpops[3].setMigrationRates(2, MIG_y); this sets from p2 to p4
			// for reasons I don't understand, this won't graph
				
			destSubpop.setValue("opt0", OPTS_0[destID - 1]);
			destSubpop.setValue("opt1", OPTS_1[destID - 1]);
			destSubpop.setValue("x", x);
			destSubpop.setValue("y", y);
			
			xd = ((x - 1) / (METAPOP_SIDE_x - 1)) * 0.9 + 0.05;
			yd = ((y - 1) / (METAPOP_SIDE_y - 1)) * 0.9 + 0.05;
			
			if (F)
			{
				// this version lets you visualize an environmental variable using a color gradient
				col = rgb2color(hsv2rgb(c(destSubpop.getValue("opt1"), 1.0, 1.0)));
				destSubpop.configureDisplay(c(xd, yd), 2.0, color=col);
			}
			else
			{
				// this version lets normal fitness coloring occur
				destSubpop.configureDisplay(c(xd, yd), 2.0);
			}
		}
	}
	} // END ESTUARY
	
	if (demog=="SS"){ // STEPPING STONE DEMOGRAPHY
	for (x in 1:METAPOP_SIDE_x)
		for (y in 1:METAPOP_SIDE_y)
		{
			destID = (x - 1) + (y - 1) * METAPOP_SIDE_x + 1;
			destSubpop = subpops[destID - 1];
			if (x > 1) // Left to right
			{ 
				if (isVariableM ==0)
				{
					destSubpop.setMigrationRates(destID - 1, MIG_x);
				}
				if (isVariableM ==1)
				{
					destSubpop.setMigrationRates(destID - 1, sample(c(0.001,0.01,0.1,0.25), 1));
				}
			}
			if (x < METAPOP_SIDE_x) // Right to left
			{
				if (isVariableM == 0)
				{
					destSubpop.setMigrationRates(destID + 1, MIG_x);
				}
				if (isVariableM == 1)
				{
					destSubpop.setMigrationRates(destID + 1, sample(c(0.001,0.01,0.1,0.25), 1));
				}
			}
			if (y > 1) // Top to bottom
			{
					if (isVariableM == 0)
					{
						destSubpop.setMigrationRates(destID - METAPOP_SIDE_x, MIG_y);
					}
					if (isVariableM == 1)
					{
						destSubpop.setMigrationRates(destID - METAPOP_SIDE_x, sample(c(0.001,0.01,0.1,0.25), 1));
					}
			}
				
			if (y < METAPOP_SIDE_y) // Bottom to top
			{
					if (isVariableM == 0)
					{
					destSubpop.setMigrationRates(destID + METAPOP_SIDE_x, MIG_y);
					}
					if (isVariableM == 1)
					{
					destSubpop.setMigrationRates(destID + METAPOP_SIDE_x, sample(c(0.001,0.01,0.1,0.25), 1));
					}
			}
				
				
			destSubpop.setValue("opt0", OPTS_0[destID - 1]);
			destSubpop.setValue("opt1", OPTS_1[destID - 1]);
			destSubpop.setValue("x", x);
			destSubpop.setValue("y", y);
			
			xd = ((x - 1) / (METAPOP_SIDE_x - 1)) * 0.9 + 0.05;
			yd = ((y - 1) / (METAPOP_SIDE_y - 1)) * 0.9 + 0.05;
			
			destSubpop.setValue("xd", xd);
			destSubpop.setValue("yd", yd);
		
		}
	} // END SS
}

function (void)outputMigration(string$ path)
{
	s = sim.subpopulations;
	m = matrix(rep(0.0, (size(s) + 1) * (size(s) + 1)), nrow=size(s) + 1, ncol=size(s) + 1);
	
	for (i in seqAlong(s))
	{
		s_i = s[i];
		s_i_mig = s_i.immigrantSubpopIDs;
		s_i_frac = s_i.immigrantSubpopFractions;
		
		for (j in seqAlong(s))
		{
			s_j = s[j];
			match = (s_i_mig == s_j.id);
			
			if (sum(match))
			{
				which_match = which(match);
				m[i+1, j+1] = s_i_frac[which_match];
			}
		}
	}
	
	contents = NULL;
	for (i in seqAlong(1:(size(s)+1)))
	{
		line = "[" + paste(m[i,], sep=",") + "],";
		contents = c(contents, line);
	}
	//	for (i in seqAlong(1:(size(s)+1)))
	//	{
	//		line = paste(m[i,], sep=",");
	//		if (i == 0)
	//			line = "[[" + line + "],";
	//		else if (i == size(s))
	//			line = "[" + line + "]]";
	//		else
	//			line = "[" + line + "],";
	//		contents = c(contents, line);
	//	}
	
	writeFile(path, contents);
}


1 {
	for (i in 1:METAPOP_NPOPS){
	
		x = (i-1)%10;
		y = floor((i-1)/10);
		if (Nequal == 0){
			sim.addSubpop(i, N); // equal population size
		}
		if (Nequal == 1){
			sim.addSubpop(i, N[x]); // N cline x axis
		}
		if (Nequal == 2){
			sim.addSubpop(i, N[y]); // N cline y axis if Nequal=2
		}
		if (Nequal == 3){
			sim.addSubpop(i, sample(N,1)); // variable N
		}
		if (Nequal ==4){
			N2 = round(dmvnorm(c(x,y), mu=c(4.5,4.5), sigma=matrix(c(4.95,0,0,4.95), nrow=2))*10000 + 5);
			sim.addSubpop(i, N); // range center largest N
		}
		
	}
	
	
	setUpMigration();
	
	// Write population information to file
	pop_head = "seed subpopID N opt0 opt1 x y";
	writeFile(paste(c(MY_RESULTS_PATH, getSeed(), "_popInfo.txt"), sep=""), pop_head, append=F);
	
	for (i in 1:METAPOP_NPOPS){

		out=paste(getSeed(),	sim.subpopulations[i-1].id, sim.subpopulations[i-1].individualCount, sim.subpopulations[i-1].getValue("opt0"),	sim.subpopulations[i-1].getValue("opt1"), sim.subpopulations[i-1].getValue("x"), sim.subpopulations[i-1].getValue("y"));

		writeFile(paste(c(MY_RESULTS_PATH, getSeed(), "_popInfo.txt"), sep=""), out, append=T);
	}	
	
	// Write migration to file for plotting
	// this is redundant with the migration matrix above, but that is used for pyslim
	// this is used to make sure the sim is doing what I think it is doing
	
	s = sim.subpopulations;
	pop_m_head = "to from m";
	writeFile(paste(c(MY_RESULTS_PATH, getSeed(), "_popInfo_m.txt"), sep=""), pop_m_head, append=F);
	for (i in seqAlong(s))
	{
		s_i = s[i];
		s_i_mig = s_i.immigrantSubpopIDs; // The identifiers of the particular subpopulations from which immigrants will arrive in the next generation.
		s_i_frac = s_i.immigrantSubpopFractions; // The expected value of the fraction of children in the next generation that are immigrants arriving from particular subpopulations.
		
		for (j in seqAlong(s_i_mig))
		{
		out=paste(i+1, s_i_mig[j], s_i_frac[j]);
		writeFile(paste(c(MY_RESULTS_PATH, getSeed(), "_popInfo_m.txt"), sep=""), out, append=T);
		}
			
	}
		
	
	outputMigration(MY_RESULTS_PATH+MY_SEED +"_mig_mat.txt");
	//sim.rescheduleScriptBlock(s1, Burnin);
	//sim.rescheduleScriptBlock(s2, Burnin, Sim_Len);
	//sim.rescheduleScriptBlock(s3, Sim_Len);
	
	
	// write information to file
	info_head = "seed MIG_x MIG_y N mu r BURNIN_1 BURNIN_2 TOTAL_GEN METAPOP_SIDE_x METAPOP_SIDE_y SIGMA_K_1 SIGMA_K_2 SIGMA_K_Cov SIGMA_QTN_1 SIGMA_QTN_2 SIGMA_QTN_Cov demog Ntraits ispleiotropy iscontrol Nequal isVariableM";

	writeFile(paste(c(MY_RESULTS_PATH, getSeed(), "_info.txt"), sep=""), info_head, append=F);
	info=paste(getSeed() ,MIG_x, MIG_y, N, sim.chromosome.mutationRates,R,BURNIN_1, BURNIN_2, TOTAL_GEN, METAPOP_SIDE_x, METAPOP_SIDE_y, SIGMA_K_1, SIGMA_K_2, SIGMA_K_Cov, SIGMA_QTN_1, SIGMA_QTN_2, SIGMA_QTN_Cov, demog, N_traits, ispleiotropy, iscontrol, Nequal, isVariableM);
	writeFile(paste(c(MY_RESULTS_PATH, getSeed(), "_info.txt"), sep=""), info, append=T);
	
	// write local adaptation file
	LA_head = "seed gen sympatric allopatric local_adapt mean_phen0 mean_phen1 cor_sal_popmean cor_temp_popeman cor_sal_ind cor_temp_ind";
	writeFile(paste(c(MY_RESULTS_PATH, getSeed(), "_LA.txt"), sep=""), LA_head, append=F);
}

mutation(m2) {
	// draw mutational effects for the new m2 mutation
	if (ispleiotropy==1){	
		effects = rmvnorm(1, QTL_mu, QTL_sigma);
		mut.setValue("e0", effects[0]);
		mut.setValue("e1", effects[1]);
	}
	
	if (ispleiotropy==0){
		effects = rmvnorm(1, QTL_mu*2, QTL_sigma);
		// this is multiplied by 2, because in the non-pleiotropy case I've hacked it so that the mutations are still pleiotropic (so the rest of the code works), but then I make them non-pleiotropic by randomly setting the mutational effect on one trait to 0. In essence, this halves the mutation rate for the non-pleiotropic case compared to the pleiotropic case for each trait. This hack (QTL_mu*2) make the mutation rates equal between the pleiotropic and non-pleiotropic cases.
		mut.setValue("e0", effects[0]);
		mut.setValue("e1", effects[1]);
		bob = sample(c(0,1), 1);
		if (bob==0){
			mut.setValue("e0", 0);
		}	
		if (bob==1){
			mut.setValue("e1", 0);
		}
	}
	return T;
}

late() {
	for (subpop in sim.subpopulations)
	{
		// calculate fitness optima
		opt0 = subpop.getValue("opt0");
		opt1 = subpop.getValue("opt1");
		if (sim.generation < BURNIN_1)
		{
			opt0 = 0;
			opt1 = 0;
			fitness_var = SIGMA_STAT;
		}
		
		if (sim.generation < BURNIN_2)
		{
			opt0 = opt0 * ((sim.generation - BURNIN_1) / (BURNIN_2 - BURNIN_1));
			opt1 = opt1 * ((sim.generation - BURNIN_1) / (BURNIN_2 - BURNIN_1));
			fitness_var_1 = SIGMA_K_1 * ((sim.generation- BURNIN_1) / (BURNIN_2 - BURNIN_1)) + SIGMA_STAT * (1.0 - (sim.generation- BURNIN_1) / (BURNIN_2 - BURNIN_1));
			fitness_var_2 = SIGMA_K_2 * ((sim.generation- BURNIN_1) / (BURNIN_2 - BURNIN_1)) + SIGMA_STAT * (1.0 - (sim.generation- BURNIN_1) / (BURNIN_2 - BURNIN_1));
		}
		opts = c(opt0, opt1);
		subpop.setValue("scaled_opt0", opt0);
		subpop.setValue("scaled_opt1", opt1);
		
		// calculate the fitness covariance matrix, sigma, normalization factor
		if (sim.generation >= BURNIN_2)
		
		fitness_var_1 = SIGMA_K_1;
		fitness_var_2 = SIGMA_K_2;
		if (N_traits == 2)
		{
			fitness_cov = SIGMA_K_Cov;
			fitness_varcov = matrix(c(fitness_var_1, fitness_cov, fitness_cov, fitness_var_2), nrow=2);
			fitness_norm = dmvnorm(c(0.0, 0.0), c(0.0, 0.0), fitness_varcov);
		subpop.setValue("fitness_varcov", fitness_varcov);
		subpop.setValue("fitness_norm", fitness_norm);
		}
		if (N_traits == 1)
		{
			fitness_norm = dnorm(0.0, 0.0, fitness_var);
			subpop.setValue("fitness_norm", fitness_norm);
		}
		
		for (ind in subpop.individuals)
		{
			// construct phenotypes from additive effects of QTL mutations
			muts = ind.genomes.mutationsOfType(m2);
			ind.setValue("phenotype0", size(muts) ? sum(muts.getValue("e0")) else 0.0);
			ind.setValue("phenotype1", size(muts) ? sum(muts.getValue("e1")) else 0.0);
		}
		
		// calculate fitness effects - normalize the height of the finess function to be 1.0
		inds = subpop.individuals;
		
		if (N_traits == 2){
			fits = dmvnorm(cbind(inds.getValue("phenotype0"), inds.getValue("phenotype1")), opts, fitness_varcov) / fitness_norm;
		}
		if (N_traits == 1){
			fits = dnorm(inds.getValue("phenotype1"), opts[1], fitness_var)/fitness_norm;
		}
		if (iscontrol == 1){
			fits = rep(1, length(inds));
		}
		
		inds.fitnessScaling = fits;
		for(i in seqAlong(inds))
			inds[i].setValue("fitness", fits[i]);
	}
	
// calculate and print common garden results; this is based upon the fitness code above
	if (sim.generation % 100 == 0)
	{
		subpops = sim.subpopulations;
		all_opt0 = subpops.getValue("opt0");
		all_opt1 = subpops.getValue("opt1");
		mean_phen0 = rep(0.0, length(subpops));
		mean_phen1 = rep(0.0, length(subpops));
		
		nsubpops = size(subpops);
		ninds = size(sim.subpopulations.individuals);
		fitness_matrix_pop = matrix(rep(0.0, nsubpops*nsubpops), nrow=nsubpops, ncol=nsubpops);
		
		if(sim.generation==TOTAL_GEN)
			fitness_matrix_ind = matrix(rep(0.0, ninds*(nsubpops+1)), nrow=(nsubpops+1), ncol=ninds);
		
		ind_index_start = 0;
		for (source_index in seqAlong(subpops))
		{
			source_subpop = subpops[source_index];
			inds = source_subpop.individuals;
			phenotype0 = inds.getValue("phenotype0");
			phenotype1 = inds.getValue("phenotype1");
			mean_phen0[source_index] = mean(phenotype0);
			mean_phen1[source_index] = mean(phenotype1);
			ind_index_end = ind_index_start + length(inds)-1;
			
			for (test_index in seqAlong(subpops))
			{
				test_subpop = subpops[test_index];
				opt0 = test_subpop.getValue("scaled_opt0");
				opt1 = test_subpop.getValue("scaled_opt1");
				fitness_norm = test_subpop.getValue("fitness_norm");
				
				if (N_traits == 2)
				{
					fitness_varcov = test_subpop.getValue("fitness_varcov");
					fitnesses = dmvnorm(cbind(phenotype0, phenotype1), c(opt0, opt1), fitness_varcov) / fitness_norm;
				}
				
				if (N_traits == 1)
				{
					fitnesses = dnorm(phenotype1, opt1, SIGMA_K_1)/fitness_norm;
				}

				fitness_matrix_pop[test_index,source_index] = mean(fitnesses);
				
				if(sim.generation==TOTAL_GEN){
					// The first row in the individual fitness matrix is their source population
					fitness_matrix_ind[0, ind_index_start:ind_index_end] = rep(source_index, length(inds));
						// fill in individual fitness matrix - test population in rows, individuals in columns
					fitness_matrix_ind[(test_index+1), ind_index_start:ind_index_end] = fitnesses;
				}
			}// end for loop
			
			ind_index_start = ind_index_end + 1;//update param
		}// end for loop
		
		diagonals = rep(0.0, nsubpops);
	
		for (i in seqAlong(diagonals)){
			diagonals[i] = fitness_matrix_pop[i,i];
			
			if(sim.generation==TOTAL_GEN){
				CG_fit = fitness_matrix_pop[i,];
				if(i==0){
					writeFile(paste(c(MY_RESULTS_PATH, getSeed(), "_fitnessmat.txt"), sep=""), paste(CG_fit), append=F);
				}else{
					writeFile(paste(c(MY_RESULTS_PATH, getSeed(), "_fitnessmat.txt"), sep=""), paste(CG_fit), append=T);
				}
			}//end if
		}// end diagonals loop
		
		
		//////////////////////////////////////////////////
		//////////// FINAL GEN OUTPUT ////////////////////
		//////////////////////////////////////////////////
		if(sim.generation==TOTAL_GEN){ // write individual fitness matrix to file
			for (i in 0:nsubpops){
				if(i==0){
					writeFile(paste(c(MY_RESULTS_PATH, getSeed(), "_fitnessmat_ind.txt"), sep=""), paste(fitness_matrix_ind[i,]), append=F);
				}else{
					writeFile(paste(c(MY_RESULTS_PATH, getSeed(), "_fitnessmat_ind.txt"), sep=""), paste(fitness_matrix_ind[i,]), append=T);
				}
			}// end loop through subpops
			
			nmut = sim.countOfMutationsOfType(m2);
			MAF = sim.mutationFrequencies(sim.subpopulations);
			whichmuts = which(MAF>0.01 & MAF < 0.99);
			MAF_whichmuts = MAF[whichmuts];
			mutNames_whichmuts = sim.mutations.id[whichmuts];
			subpops = sim.subpopulations;
			freq = matrix(rep(0.0,length(whichmuts)*length(subpops)) , nrow=length(whichmuts), ncol=length(subpops));
		// mutations in rows and subpops in columns
			for (i in seqAlong(subpops)){
				freq[,i] = sim.mutationFrequencies(subpops[i],  sim.mutationsOfType(m2)[whichmuts]);
			}
			all_opt0 = subpops.getValue("opt0");
			all_opt1 = subpops.getValue("opt1");
			mutSalEffect_whichmuts = sim.mutations.getValue("e0")[whichmuts];
			mutTempEffect_whichmuts = sim.mutations.getValue("e1")[whichmuts];
			//cor_sal_muts = rep(0.0, length(whichmuts));
			//cor_temp_muts = rep(0.0, length(whichmuts));
			writeFile(paste(c(MY_RESULTS_PATH, getSeed(), "_muts.txt"), sep=""), paste(c("seed", "mutID","muttype","p", "cor_sal","cor_temp", "mutSalEffect","mutTempEffect")));
	
		for (i in seqAlong(whichmuts)){
			//thismutfreqs = freq[i,];
			cor_sal_muts = cor(all_opt0, drop(freq[i,]));
			cor_temp_muts = cor(all_opt1, drop(freq[i,]));
			out_i = paste(MY_SEED, mutNames_whichmuts[i],"m2", MAF_whichmuts[i], cor_sal_muts,  cor_temp_muts, mutSalEffect_whichmuts[i], mutTempEffect_whichmuts[i]);
			writeFile(paste(c(MY_RESULTS_PATH, getSeed(), "_muts.txt"), sep=""), out_i, append=T);
		}
	
		inds = sim.subpopulations.individuals;
		inds.genomes.outputVCF(paste(c(MY_RESULTS_PATH, getSeed(), "_VCF_causal.vcf"), sep=""));
	
		phenotype0 = inds.getValue("phenotype0");
		phenotype1 = inds.getValue("phenotype1");
		indsubpop = inds.subpopulation;
			all_opt0_inds = inds.subpopulation.getValue("scaled_opt0");
		all_opt1_inds = inds.subpopulation.getValue("scaled_opt1");
		cor(phenotype0, all_opt0_inds);
		cor(phenotype1, all_opt1_inds);
		
		writeFile(paste(c(MY_RESULTS_PATH, getSeed(), "_ind.txt"), sep=""), paste(c("seed", "indID","indSubpopIndex", "subpop", "phen_sal", "phen_temp",  "sal_opt", "temp_opt", "fitness")));
		
		k=0;	
		for (i in seqAlong(inds)){
			out_i = paste(MY_SEED, k, inds[i].index, indsubpop[i].id, phenotype0[i], phenotype1[i], indsubpop[i].getValue("scaled_opt0"), indsubpop[i].getValue("scaled_opt1"), inds[i].getValue("fitness"));
			writeFile(paste(c(MY_RESULTS_PATH, getSeed(), "_ind.txt"), sep=""), out_i, append=T);
			k=k+1;
		}// end loop through individuals
		
		sim.treeSeqOutput(paste(c(MY_RESULTS_PATH,MY_SEED,".trees"), sep=""));
		
	}//end if
		//////////////////////////////////////////////////
		//////////// END FINAL GEN OUTPUT ////////////////////
		//////////////////////////////////////////////////
		
		
		// Calculate LA every 100 generations
		sympatric = mean(diagonals);
		allopatric = (sum(fitness_matrix_pop) - sum(diagonals)) / (length(fitness_matrix_pop) - length(diagonals));
		local_adapt = sympatric - allopatric;
		
		cor_sal_popmean = cor(all_opt0, mean_phen0);
		cor_temp_popmean = cor(all_opt1, mean_phen1);
		
		inds = sim.subpopulations.individuals;
		phenotype0_all = inds.getValue("phenotype0");
		phenotype1_all = inds.getValue("phenotype1");
		all_opt0_inds = inds.subpopulation.getValue("scaled_opt0");
		all_opt1_inds = inds.subpopulation.getValue("scaled_opt1");
		cor_sal_ind = cor(phenotype0_all, all_opt0_inds);
		cor_temp_ind = cor(phenotype1_all, all_opt1_inds);
		
		LA = paste(MY_SEED, sim.generation, sympatric, allopatric, local_adapt, mean(mean_phen0), mean(mean_phen1), cor_sal_popmean, cor_temp_popmean, cor_sal_ind, cor_temp_ind);
		catn(sim.generation + ":" + sympatric +" "+ allopatric +" "+ local_adapt +" "+mean(mean_phen0)+" "+mean(mean_phen1)+" "+ cor_sal_popmean +" "+ cor_temp_popmean +" "+ cor_sal_ind +" "+cor_temp_ind);
		//catn(sim.generation + ":" +mean(mean_phen0)+" "+mean(mean_phen1));
		
		writeFile(paste(c(MY_RESULTS_PATH, getSeed(), "_LA.txt"), sep=""), LA, append=T);
		
			
	}//end if 100 generations
	
}

3000{ //output on last generation

	
}
